// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: invoice.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO
    invoice (
        business_id,
        currency,
        payment_due_date,
        date_of_issue,
        notes,
        payment_method,
        payment_status,
        client_id,
        shipping_fee_type,
        shipping_fee,
        items
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    ) RETURNING id, created_at, updated_at, deleted_at, business_id, currency, payment_due_date, date_of_issue, notes, payment_method, payment_status, items, client_id, shipping_fee_type, shipping_fee
`

type CreateInvoiceParams struct {
	BusinessID      uuid.UUID        `db:"business_id" json:"business_id"`
	Currency        *string          `db:"currency" json:"currency"`
	PaymentDueDate  *time.Time       `db:"payment_due_date" json:"payment_due_date"`
	DateOfIssue     *time.Time       `db:"date_of_issue" json:"date_of_issue"`
	Notes           *string          `db:"notes" json:"notes"`
	PaymentMethod   *string          `db:"payment_method" json:"payment_method"`
	PaymentStatus   *string          `db:"payment_status" json:"payment_status"`
	ClientID        *uuid.UUID       `db:"client_id" json:"client_id"`
	ShippingFeeType *string          `db:"shipping_fee_type" json:"shipping_fee_type"`
	ShippingFee     *decimal.Decimal `db:"shipping_fee" json:"shipping_fee"`
	Items           []byte           `db:"items" json:"items"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.BusinessID,
		arg.Currency,
		arg.PaymentDueDate,
		arg.DateOfIssue,
		arg.Notes,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.ClientID,
		arg.ShippingFeeType,
		arg.ShippingFee,
		arg.Items,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BusinessID,
		&i.Currency,
		&i.PaymentDueDate,
		&i.DateOfIssue,
		&i.Notes,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Items,
		&i.ClientID,
		&i.ShippingFeeType,
		&i.ShippingFee,
	)
	return i, err
}

const deleteInvoiceById = `-- name: DeleteInvoiceById :exec
Delete From
    invoice
WHERE
    id = $1
`

func (q *Queries) DeleteInvoiceById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvoiceById, id)
	return err
}

const getInvoiceWhere = `-- name: GetInvoiceWhere :many
SELECT
    invoice.id, invoice.created_at, invoice.updated_at, invoice.deleted_at, invoice.business_id, invoice.currency, invoice.payment_due_date, invoice.date_of_issue, invoice.notes, invoice.payment_method, invoice.payment_status, invoice.items, invoice.client_id, invoice.shipping_fee_type, invoice.shipping_fee,
    COUNT(*) OVER () AS total_count
FROM
    invoice
WHERE
    (business_id = COALESCE($1, business_id))
    AND (id = COALESCE($2, id))
    AND (client_id = COALESCE($3, client_id))
    AND (payment_status = COALESCE($4, payment_status))
    AND (payment_method = COALESCE($5, payment_method))
    AND (
        shipping_fee_type = COALESCE($6, shipping_fee_type)
    )
    AND (currency = COALESCE($7, currency))
    AND (payment_status = COALESCE($8, payment_status))
    AND (payment_method = COALESCE($9, payment_method))
ORDER BY
    created_at ASC
LIMIT
    $10 OFFSET $11
`

type GetInvoiceWhereParams struct {
	BusinessID      uuid.UUID  `db:"business_id" json:"business_id"`
	ID              uuid.UUID  `db:"id" json:"id"`
	ClientID        *uuid.UUID `db:"client_id" json:"client_id"`
	PaymentStatus   *string    `db:"payment_status" json:"payment_status"`
	PaymentMethod   *string    `db:"payment_method" json:"payment_method"`
	ShippingFeeType *string    `db:"shipping_fee_type" json:"shipping_fee_type"`
	Currency        *string    `db:"currency" json:"currency"`
	PaymentStatus_2 *string    `db:"payment_status_2" json:"payment_status_2"`
	PaymentMethod_2 *string    `db:"payment_method_2" json:"payment_method_2"`
	Limit           int32      `db:"limit" json:"limit"`
	Offset          int32      `db:"offset" json:"offset"`
}

type GetInvoiceWhereRow struct {
	Invoice    Invoice `db:"invoice" json:"invoice"`
	TotalCount int64   `db:"total_count" json:"total_count"`
}

func (q *Queries) GetInvoiceWhere(ctx context.Context, arg GetInvoiceWhereParams) ([]GetInvoiceWhereRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceWhere,
		arg.BusinessID,
		arg.ID,
		arg.ClientID,
		arg.PaymentStatus,
		arg.PaymentMethod,
		arg.ShippingFeeType,
		arg.Currency,
		arg.PaymentStatus_2,
		arg.PaymentMethod_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoiceWhereRow
	for rows.Next() {
		var i GetInvoiceWhereRow
		if err := rows.Scan(
			&i.Invoice.ID,
			&i.Invoice.CreatedAt,
			&i.Invoice.UpdatedAt,
			&i.Invoice.DeletedAt,
			&i.Invoice.BusinessID,
			&i.Invoice.Currency,
			&i.Invoice.PaymentDueDate,
			&i.Invoice.DateOfIssue,
			&i.Invoice.Notes,
			&i.Invoice.PaymentMethod,
			&i.Invoice.PaymentStatus,
			&i.Invoice.Items,
			&i.Invoice.ClientID,
			&i.Invoice.ShippingFeeType,
			&i.Invoice.ShippingFee,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :one
Update
    invoice
SET
    updated_at = timezone('utc', now()),
    currency = COALESCE($2, currency),
    payment_due_date = COALESCE($3, payment_due_date),
    date_of_issue = COALESCE($4, date_of_issue),
    notes = COALESCE($5, notes),
    payment_method = COALESCE($6, payment_method),
    payment_status = COALESCE($7, payment_status),
    client_id = COALESCE($8, client_id),
    shipping_fee_type = COALESCE($9, shipping_fee_type),
    shipping_fee = COALESCE($10, shipping_fee),
    items = COALESCE($11, items)
WHERE
    id = $1 RETURNING id, created_at, updated_at, deleted_at, business_id, currency, payment_due_date, date_of_issue, notes, payment_method, payment_status, items, client_id, shipping_fee_type, shipping_fee
`

type UpdateInvoiceParams struct {
	ID              uuid.UUID        `db:"id" json:"id"`
	Currency        *string          `db:"currency" json:"currency"`
	PaymentDueDate  *time.Time       `db:"payment_due_date" json:"payment_due_date"`
	DateOfIssue     *time.Time       `db:"date_of_issue" json:"date_of_issue"`
	Notes           *string          `db:"notes" json:"notes"`
	PaymentMethod   *string          `db:"payment_method" json:"payment_method"`
	PaymentStatus   *string          `db:"payment_status" json:"payment_status"`
	ClientID        *uuid.UUID       `db:"client_id" json:"client_id"`
	ShippingFeeType *string          `db:"shipping_fee_type" json:"shipping_fee_type"`
	ShippingFee     *decimal.Decimal `db:"shipping_fee" json:"shipping_fee"`
	Items           []byte           `db:"items" json:"items"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoice,
		arg.ID,
		arg.Currency,
		arg.PaymentDueDate,
		arg.DateOfIssue,
		arg.Notes,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.ClientID,
		arg.ShippingFeeType,
		arg.ShippingFee,
		arg.Items,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BusinessID,
		&i.Currency,
		&i.PaymentDueDate,
		&i.DateOfIssue,
		&i.Notes,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Items,
		&i.ClientID,
		&i.ShippingFeeType,
		&i.ShippingFee,
	)
	return i, err
}
