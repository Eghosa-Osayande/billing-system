// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: invoice.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO
    invoice (
        business_id,
        currency,
        currency_symbol,
        payment_due_date,
        date_of_issue,
        notes,
        payment_method,
        client_id,
        shipping_fee_type,
        shipping_fee,
        total,
        tax
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    ) RETURNING id, created_at, updated_at, deleted_at, business_id, currency, currency_symbol, payment_due_date, date_of_issue, notes, payment_method, payment_status, client_id, shipping_fee_type, shipping_fee, tax, invoice_number, total
`

type CreateInvoiceParams struct {
	BusinessID      uuid.UUID          `db:"business_id" json:"business_id"`
	Currency        *string            `db:"currency" json:"currency"`
	CurrencySymbol  *string            `db:"currency_symbol" json:"currency_symbol"`
	PaymentDueDate  pgtype.Timestamptz `db:"payment_due_date" json:"payment_due_date"`
	DateOfIssue     pgtype.Timestamptz `db:"date_of_issue" json:"date_of_issue"`
	Notes           *string            `db:"notes" json:"notes"`
	PaymentMethod   *string            `db:"payment_method" json:"payment_method"`
	ClientID        *uuid.UUID         `db:"client_id" json:"client_id"`
	ShippingFeeType *string            `db:"shipping_fee_type" json:"shipping_fee_type"`
	ShippingFee     *decimal.Decimal   `db:"shipping_fee" json:"shipping_fee"`
	Total           *decimal.Decimal   `db:"total" json:"total"`
	Tax             *decimal.Decimal   `db:"tax" json:"tax"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.BusinessID,
		arg.Currency,
		arg.CurrencySymbol,
		arg.PaymentDueDate,
		arg.DateOfIssue,
		arg.Notes,
		arg.PaymentMethod,
		arg.ClientID,
		arg.ShippingFeeType,
		arg.ShippingFee,
		arg.Total,
		arg.Tax,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BusinessID,
		&i.Currency,
		&i.CurrencySymbol,
		&i.PaymentDueDate,
		&i.DateOfIssue,
		&i.Notes,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.ClientID,
		&i.ShippingFeeType,
		&i.ShippingFee,
		&i.Tax,
		&i.InvoiceNumber,
		&i.Total,
	)
	return i, err
}

const deleteInvoiceById = `-- name: DeleteInvoiceById :exec
Delete From
    invoice
WHERE
    id = $1
`

func (q *Queries) DeleteInvoiceById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvoiceById, id)
	return err
}

const findInvoiceById = `-- name: FindInvoiceById :one
SELECT
    id, created_at, updated_at, deleted_at, business_id, currency, currency_symbol, payment_due_date, date_of_issue, notes, payment_method, payment_status, client_id, shipping_fee_type, shipping_fee, tax, invoice_number, total
FROM
    invoice
WHERE
    (invoice.id = $1)
`

func (q *Queries) FindInvoiceById(ctx context.Context, id uuid.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, findInvoiceById, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BusinessID,
		&i.Currency,
		&i.CurrencySymbol,
		&i.PaymentDueDate,
		&i.DateOfIssue,
		&i.Notes,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.ClientID,
		&i.ShippingFeeType,
		&i.ShippingFee,
		&i.Tax,
		&i.InvoiceNumber,
		&i.Total,
	)
	return i, err
}

const findInvoicesWhere = `-- name: FindInvoicesWhere :many
SELECT
    invoice.id, invoice.created_at, invoice.updated_at, invoice.deleted_at, invoice.business_id, invoice.currency, invoice.currency_symbol, invoice.payment_due_date, invoice.date_of_issue, invoice.notes, invoice.payment_method, invoice.payment_status, invoice.client_id, invoice.shipping_fee_type, invoice.shipping_fee, invoice.tax, invoice.invoice_number, invoice.total,
    JSON_AGG(client.*) as client,
    JSON_AGG(invoiceitem.*) as items
FROM
    invoice
    LEFT JOIN invoiceitem ON invoice.id = invoiceitem.invoice_id
    LEFT JOIN client ON invoice.client_id = client.id
WHERE
    (
        (
            (
                $1 :: uuid is not null
                and invoice.business_id = $1
            )
            or $1 is null
        )
        and (
            (
                $2 :: uuid is not null
                and invoice.client_id = $2
            )
            or $2 is null
        ) 
        and (
            (
                $3 :: uuid is not null
                and invoice.id = $3
            )
            or $3 is null
        )
        and (
            (
                $4 :: timestamptz is not null
                and invoice.created_at <= $4 :: timestamptz
            )
            or $4 :: timestamptz is null
        )
        and (
            (
                $5 :: uuid is not null
                and invoice.id != $5 :: uuid
            )
            or $5 :: uuid is null
        )

    )
    
GROUP BY
    invoice.id,
    client.id
ORDER BY
    invoice.created_at DESC,
    invoice.id DESC
LIMIT
    COALESCE($6, 1)
`

type FindInvoicesWhereParams struct {
	BusinessID *uuid.UUID         `db:"business_id" json:"business_id"`
	ClientID   *uuid.UUID         `db:"client_id" json:"client_id"`
	InvoiceID  *uuid.UUID         `db:"invoice_id" json:"invoice_id"`
	CursorTime pgtype.Timestamptz `db:"cursor_time" json:"cursor_time"`
	CursorID   *uuid.UUID         `db:"cursor_id" json:"cursor_id"`
	Limit      interface{}        `db:"limit" json:"limit"`
}

type FindInvoicesWhereRow struct {
	Invoice Invoice `db:"invoice" json:"invoice"`
	Client  []byte  `db:"client" json:"client"`
	Items   []byte  `db:"items" json:"items"`
}

func (q *Queries) FindInvoicesWhere(ctx context.Context, arg FindInvoicesWhereParams) ([]FindInvoicesWhereRow, error) {
	rows, err := q.db.Query(ctx, findInvoicesWhere,
		arg.BusinessID,
		arg.ClientID,
		arg.InvoiceID,
		arg.CursorTime,
		arg.CursorID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindInvoicesWhereRow
	for rows.Next() {
		var i FindInvoicesWhereRow
		if err := rows.Scan(
			&i.Invoice.ID,
			&i.Invoice.CreatedAt,
			&i.Invoice.UpdatedAt,
			&i.Invoice.DeletedAt,
			&i.Invoice.BusinessID,
			&i.Invoice.Currency,
			&i.Invoice.CurrencySymbol,
			&i.Invoice.PaymentDueDate,
			&i.Invoice.DateOfIssue,
			&i.Invoice.Notes,
			&i.Invoice.PaymentMethod,
			&i.Invoice.PaymentStatus,
			&i.Invoice.ClientID,
			&i.Invoice.ShippingFeeType,
			&i.Invoice.ShippingFee,
			&i.Invoice.Tax,
			&i.Invoice.InvoiceNumber,
			&i.Invoice.Total,
			&i.Client,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :one
Update
    invoice
SET
    updated_at = timezone('utc', now()),
    currency = COALESCE($2, currency),
    payment_due_date = COALESCE($3, payment_due_date),
    date_of_issue = COALESCE($4, date_of_issue),
    notes = COALESCE($5, notes),
    payment_method = COALESCE($6, payment_method),
    client_id = COALESCE($7, client_id),
    shipping_fee_type = COALESCE($8, shipping_fee_type),
    shipping_fee = COALESCE($9, shipping_fee),
    total = COALESCE($10, total),
    payment_status = COALESCE($11, payment_status)
WHERE
    id = $1 RETURNING id, created_at, updated_at, deleted_at, business_id, currency, currency_symbol, payment_due_date, date_of_issue, notes, payment_method, payment_status, client_id, shipping_fee_type, shipping_fee, tax, invoice_number, total
`

type UpdateInvoiceParams struct {
	ID              uuid.UUID                `db:"id" json:"id"`
	Currency        *string                  `db:"currency" json:"currency"`
	PaymentDueDate  pgtype.Timestamptz       `db:"payment_due_date" json:"payment_due_date"`
	DateOfIssue     pgtype.Timestamptz       `db:"date_of_issue" json:"date_of_issue"`
	Notes           *string                  `db:"notes" json:"notes"`
	PaymentMethod   *string                  `db:"payment_method" json:"payment_method"`
	ClientID        *uuid.UUID               `db:"client_id" json:"client_id"`
	ShippingFeeType *string                  `db:"shipping_fee_type" json:"shipping_fee_type"`
	ShippingFee     *decimal.Decimal         `db:"shipping_fee" json:"shipping_fee"`
	Total           *decimal.Decimal         `db:"total" json:"total"`
	PaymentStatus   NullInvoicePaymentStatus `db:"payment_status" json:"payment_status"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoice,
		arg.ID,
		arg.Currency,
		arg.PaymentDueDate,
		arg.DateOfIssue,
		arg.Notes,
		arg.PaymentMethod,
		arg.ClientID,
		arg.ShippingFeeType,
		arg.ShippingFee,
		arg.Total,
		arg.PaymentStatus,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BusinessID,
		&i.Currency,
		&i.CurrencySymbol,
		&i.PaymentDueDate,
		&i.DateOfIssue,
		&i.Notes,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.ClientID,
		&i.ShippingFeeType,
		&i.ShippingFee,
		&i.Tax,
		&i.InvoiceNumber,
		&i.Total,
	)
	return i, err
}
